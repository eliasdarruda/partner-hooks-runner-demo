// @generated by protobuf-ts 2.9.3
// @generated from protobuf file "hooks.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message HookScriptState
 */
export interface HookScriptState {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
    /**
     * @generated from protobuf field: string transpiled_code = 2;
     */
    transpiledCode: string;
    /**
     * @generated from protobuf field: string json_context = 3;
     */
    jsonContext: string;
}
/**
 * @generated from protobuf message RegisterHookScriptRequest
 */
export interface RegisterHookScriptRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
}
/**
 * @generated from protobuf message Ticket
 */
export interface Ticket {
    /**
     * @generated from protobuf field: string date_string = 1;
     */
    dateString: string;
    /**
     * @generated from protobuf field: string activity_name = 2;
     */
    activityName: string;
    /**
     * @generated from protobuf field: string resource_id = 3;
     */
    resourceId: string;
    /**
     * @generated from protobuf field: float list_price = 4;
     */
    listPrice: number;
    /**
     * @generated from protobuf field: string ticket_id = 5;
     */
    ticketId: string;
}
/**
 * @generated from protobuf message PriceOverride
 */
export interface PriceOverride {
    /**
     * @generated from protobuf field: string date_string = 1;
     */
    dateString: string;
    /**
     * @generated from protobuf field: string resource_id = 2;
     */
    resourceId: string;
    /**
     * @generated from protobuf field: float new_price = 3;
     */
    newPrice: number;
}
/**
 * @generated from protobuf message AdditionalPriceResponse
 */
export interface AdditionalPriceResponse {
    /**
     * @generated from protobuf field: float amount = 1;
     */
    amount: number;
}
/**
 * @generated from protobuf message ActivityPriceOverridePayload
 */
export interface ActivityPriceOverridePayload {
    /**
     * @generated from protobuf field: repeated Ticket tickets = 1;
     */
    tickets: Ticket[];
}
/**
 * @generated from protobuf message ActivityPriceOverrideResponse
 */
export interface ActivityPriceOverrideResponse {
    /**
     * @generated from protobuf field: repeated PriceOverride overrides = 1;
     */
    overrides: PriceOverride[];
}
// @generated message type with reflection information, may provide speed optimized methods
class HookScriptState$Type extends MessageType<HookScriptState> {
    constructor() {
        super("HookScriptState", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transpiled_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "json_context", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HookScriptState>): HookScriptState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.transpiledCode = "";
        message.jsonContext = "";
        if (value !== undefined)
            reflectionMergePartial<HookScriptState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HookScriptState): HookScriptState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string transpiled_code */ 2:
                    message.transpiledCode = reader.string();
                    break;
                case /* string json_context */ 3:
                    message.jsonContext = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HookScriptState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string transpiled_code = 2; */
        if (message.transpiledCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.transpiledCode);
        /* string json_context = 3; */
        if (message.jsonContext !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.jsonContext);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HookScriptState
 */
export const HookScriptState = new HookScriptState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterHookScriptRequest$Type extends MessageType<RegisterHookScriptRequest> {
    constructor() {
        super("RegisterHookScriptRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterHookScriptRequest>): RegisterHookScriptRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterHookScriptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterHookScriptRequest): RegisterHookScriptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterHookScriptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RegisterHookScriptRequest
 */
export const RegisterHookScriptRequest = new RegisterHookScriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ticket$Type extends MessageType<Ticket> {
    constructor() {
        super("Ticket", [
            { no: 1, name: "date_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "activity_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "resource_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "list_price", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "ticket_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Ticket>): Ticket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dateString = "";
        message.activityName = "";
        message.resourceId = "";
        message.listPrice = 0;
        message.ticketId = "";
        if (value !== undefined)
            reflectionMergePartial<Ticket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ticket): Ticket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string date_string */ 1:
                    message.dateString = reader.string();
                    break;
                case /* string activity_name */ 2:
                    message.activityName = reader.string();
                    break;
                case /* string resource_id */ 3:
                    message.resourceId = reader.string();
                    break;
                case /* float list_price */ 4:
                    message.listPrice = reader.float();
                    break;
                case /* string ticket_id */ 5:
                    message.ticketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ticket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string date_string = 1; */
        if (message.dateString !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dateString);
        /* string activity_name = 2; */
        if (message.activityName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.activityName);
        /* string resource_id = 3; */
        if (message.resourceId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.resourceId);
        /* float list_price = 4; */
        if (message.listPrice !== 0)
            writer.tag(4, WireType.Bit32).float(message.listPrice);
        /* string ticket_id = 5; */
        if (message.ticketId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.ticketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ticket
 */
export const Ticket = new Ticket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceOverride$Type extends MessageType<PriceOverride> {
    constructor() {
        super("PriceOverride", [
            { no: 1, name: "date_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resource_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_price", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceOverride>): PriceOverride {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dateString = "";
        message.resourceId = "";
        message.newPrice = 0;
        if (value !== undefined)
            reflectionMergePartial<PriceOverride>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceOverride): PriceOverride {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string date_string */ 1:
                    message.dateString = reader.string();
                    break;
                case /* string resource_id */ 2:
                    message.resourceId = reader.string();
                    break;
                case /* float new_price */ 3:
                    message.newPrice = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceOverride, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string date_string = 1; */
        if (message.dateString !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dateString);
        /* string resource_id = 2; */
        if (message.resourceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resourceId);
        /* float new_price = 3; */
        if (message.newPrice !== 0)
            writer.tag(3, WireType.Bit32).float(message.newPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PriceOverride
 */
export const PriceOverride = new PriceOverride$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdditionalPriceResponse$Type extends MessageType<AdditionalPriceResponse> {
    constructor() {
        super("AdditionalPriceResponse", [
            { no: 1, name: "amount", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AdditionalPriceResponse>): AdditionalPriceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = 0;
        if (value !== undefined)
            reflectionMergePartial<AdditionalPriceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdditionalPriceResponse): AdditionalPriceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float amount */ 1:
                    message.amount = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdditionalPriceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float amount = 1; */
        if (message.amount !== 0)
            writer.tag(1, WireType.Bit32).float(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdditionalPriceResponse
 */
export const AdditionalPriceResponse = new AdditionalPriceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityPriceOverridePayload$Type extends MessageType<ActivityPriceOverridePayload> {
    constructor() {
        super("ActivityPriceOverridePayload", [
            { no: 1, name: "tickets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Ticket }
        ]);
    }
    create(value?: PartialMessage<ActivityPriceOverridePayload>): ActivityPriceOverridePayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tickets = [];
        if (value !== undefined)
            reflectionMergePartial<ActivityPriceOverridePayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityPriceOverridePayload): ActivityPriceOverridePayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Ticket tickets */ 1:
                    message.tickets.push(Ticket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityPriceOverridePayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Ticket tickets = 1; */
        for (let i = 0; i < message.tickets.length; i++)
            Ticket.internalBinaryWrite(message.tickets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityPriceOverridePayload
 */
export const ActivityPriceOverridePayload = new ActivityPriceOverridePayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityPriceOverrideResponse$Type extends MessageType<ActivityPriceOverrideResponse> {
    constructor() {
        super("ActivityPriceOverrideResponse", [
            { no: 1, name: "overrides", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PriceOverride }
        ]);
    }
    create(value?: PartialMessage<ActivityPriceOverrideResponse>): ActivityPriceOverrideResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.overrides = [];
        if (value !== undefined)
            reflectionMergePartial<ActivityPriceOverrideResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityPriceOverrideResponse): ActivityPriceOverrideResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated PriceOverride overrides */ 1:
                    message.overrides.push(PriceOverride.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityPriceOverrideResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated PriceOverride overrides = 1; */
        for (let i = 0; i < message.overrides.length; i++)
            PriceOverride.internalBinaryWrite(message.overrides[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityPriceOverrideResponse
 */
export const ActivityPriceOverrideResponse = new ActivityPriceOverrideResponse$Type();
